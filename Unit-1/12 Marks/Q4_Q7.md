# Q4. Compare and contrast BFS, DFS, and DLS

## Introduction
Search algorithms help us move from a start node to a goal node in a problem space (like graphs, trees, or mazes).  
The three common strategies are:  
- Breadth-First Search (BFS)  
- Depth-First Search (DFS)  
- Depth-Limited Search (DLS)  

## 1. Breadth-First Search (BFS)
- Expands nodes level by level.  
- Uses a queue (FIFO).  
- Always finds the shortest path if cost per step is equal.  

**Diagram (BFS Order):**
```

```
  A
/ | \
```

B  C  D
/ \    &#x20;
E   F     G

```
**Traversal:** A → B → C → D → E → F → G  

## 2. Depth-First Search (DFS)
- Goes deep along one branch first, then backtracks.  
- Uses a stack (LIFO) or recursion.  
- May get stuck in infinite depth.  
- Not guaranteed to find the shortest path.  

## 3. Depth-Limited Search (DLS)
- A version of DFS with a predefined depth limit.  
- Prevents infinite looping.  
- If the goal lies deeper than the limit → it fails.  

## 4. Comparison Table

| Feature           | BFS               | DFS             | DLS                   |
|------------------|-----------------|----------------|----------------------|
| Time Complexity   | O(b^d)          | O(b^m)         | O(b^l) (l = depth limit) |
| Space Complexity  | O(b^d) (high)   | O(bm) (low)    | O(bl)                 |
| Completeness      | Yes             | No (may loop)  | Yes, if limit ≥ solution depth |
| Optimality        | Yes (shortest)  | No             | No (unless limit = solution depth) |

**Where:**  
b = branching factor, d = depth of shallowest solution, m = maximum depth  

**Conclusion:**  
- BFS → complete & optimal but costly in memory.  
- DFS → memory efficient, but not optimal.  
- DLS → useful middle ground, depends on correct limit.

---

# Q5. Perform 4 Uninformed Searches on a Tree

Assume root = A with children B, C, D, etc.

## 1. Breadth-First Search (BFS)
- **Traversal:** A → B → C → D → E → F …  
- **Optimality:** Yes  
- **Completeness:** Yes  

## 2. Depth-First Search (DFS)
- **Traversal:** A → B → E → F → C → D …  
- **Optimality:** No  
- **Completeness:** No  

## 3. Uniform Cost Search (UCS)
- Expands node with least path cost first.  
- **Optimality:** Always optimal if costs are positive  

## 4. Depth-Limited Search (DLS)
- Works like DFS but stops at a fixed depth.  
- **Completeness:** Yes if depth limit ≥ goal depth  
- **Optimality:** No (unless limit = exact goal depth)  

✅ For full marks: show traversal order + write about completeness/optimality.

---

# Q6. Maze with 20 Rooms

## (a) BFS Node Expansion
Let Start = Room 1, Goal = Room 10.

- Level 0: {1}  
- Level 1: {2, 3, 4}  
- Level 2: {5, 6, 7, 8}  
- Level 3: {9, 10} → Goal found!  

BFS expands in layers until it hits the goal.

## (b) BFS vs DFS Comparison

| Feature           | BFS               | DFS             |
|------------------|-----------------|----------------|
| Time Complexity   | O(b^d)          | O(b^m)         |
| Space Complexity  | O(b^d) (large)  | O(bm) (small)  |
| Completeness      | Yes             | No             |
| Optimality        | Yes             | No             |

---

# Q7. Minimax & Alpha-Beta Pruning

## Minimax Strategy
Used in 2-player games (e.g., Tic-Tac-Toe, Chess).  

- **Players:**  
  - MAX → tries to maximize score  
  - MIN → tries to minimize score  

- Builds a game tree, chooses best move by simulating all outcomes  

**Example Tree:**
```

```
      MAX
    /     \
  MIN      MIN
 / \       / \
3   5     2   9
```

```
- MIN picks smaller values → left child = 3, right child = 2  
- MAX chooses the larger → final result = 5  

## Alpha-Beta Pruning
- Improves Minimax by ignoring branches that cannot affect final decision  
- **Alpha (α):** best score for MAX so far  
- **Beta (β):** best score for MIN so far  
- If α ≥ β → prune branch  

**Diagram with pruning:**
```

```
      MAX
    /     \
  MIN      MIN
 / \       / \
3   5     2   (9 is pruned)
```

```

**Advantages:**  
- Same decision as Minimax  
- Fewer nodes evaluated → faster
